虚拟机内的锁优化
a、偏向锁
     大部分情况是没有竞争的，所以可以通过偏向来提高性能
     所谓的偏向，就是偏心，即锁会偏向于当前已经占有锁的线程
     将对象头Mark的标记设置为偏向，并将线程ID写入对象头Mark
     只要没有竞争，获得偏向锁的线程，在将来进入同步块，不需要做同步
     当其他线程请求相同的锁时，偏向模式结束
     -XX:+UseBiasedLocking
    – 默认启用
     在竞争激烈的场合，偏向锁会增加系统负担
b、轻量级锁
     普通的锁处理性能不够理想，轻量级锁是一种快速的锁定方法。
     如果对象没有被锁定
    – 将对象头的Mark指针保存到锁对象中
    – 将对象头设置为指向锁的指针（在线程栈空间中）
     如果轻量级锁失败，表示存在竞争，升级为重量级锁（常规锁）
     在没有锁竞争的前提下，减少传统锁使用OS互斥量产生的性能损耗
     在竞争激烈时，轻量级锁会多做很多额外操作，导致性能下降
c、自旋锁
     当竞争存在时，如果线程可以很快获得锁，那么可以不在OS层挂起线程，让线程做几个空操作（
    自旋）
     JDK1.6中-XX:+UseSpinning开启
     JDK1.7中，去掉此参数，改为内置实现
     如果同步块很长，自旋失败，会降低系统性能
     如果同步块很短，自旋成功，节省线程挂起切换时间，提升系统性能

偏向锁，轻量级锁，自旋锁总结
     不是Java语言层面的锁优化方法
     内置于JVM中的获取锁的优化方法和获取锁的步骤
    – 偏向锁可用会先尝试偏向锁
    – 轻量级锁可用会先尝试轻量级锁
    – 以上都失败，尝试自旋锁
    – 再失败，尝试普通锁，使用OS互斥量在操作系统层挂起